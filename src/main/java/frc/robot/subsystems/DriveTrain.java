// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.sensors.CANCoder;
import com.ctre.phoenix.sensors.CANCoderConfiguration;
import com.ctre.phoenix.sensors.CANCoderFaults;
import com.ctre.phoenix.sensors.CANCoderStatusFrame;
import com.ctre.phoenix.sensors.SensorTimeBase;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

public class DriveTrain extends SubsystemBase {
  private CANSparkMax flMove = new CANSparkMax(Constants.OperatorConstants.FL_MOVE_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax flTurn = new CANSparkMax(Constants.OperatorConstants.FL_TURN_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax blMove = new CANSparkMax(Constants.OperatorConstants.BL_MOVE_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax blTurn = new CANSparkMax(Constants.OperatorConstants.BL_TURN_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax frMove = new CANSparkMax(Constants.OperatorConstants.FR_MOVE_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax frTurn = new CANSparkMax(Constants.OperatorConstants.FR_TURN_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax brMove = new CANSparkMax(Constants.OperatorConstants.BR_MOVE_MOTOR_ID, MotorType.kBrushless);
  private CANSparkMax brTurn = new CANSparkMax(Constants.OperatorConstants.BR_TURN_MOTOR_ID, MotorType.kBrushless);
  private CANCoder cancoder;
  private CANCoder fl;
  private CANCoder fr;
  private CANCoder bl;
  private CANCoder br;

  
  /* Creates a new DriveTrain. */
  public DriveTrain(){
    //TODO: Fix device Id/ numbers
    fl = new CANCoder(1);
    fr = new CANCoder(2);
    bl = new CANCoder(3);
    br = new CANCoder(4);
  CANCoderConfiguration config = new CANCoderConfiguration();
  // set units of the CANCoder to radians, with velocity being radians per second
  config.sensorCoefficient = 2 * Math.PI / 4096.0;
  config.unitString = "rad";
  config.sensorTimeBase = SensorTimeBase.PerSecond;
  fl.configAllSettings(config);
  fl.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms    
  fr.configAllSettings(config);
  fr.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms     
  bl.configAllSettings(config);
  bl.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms    
  br.configAllSettings(config);
  br.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms   
  /*
  System.out.println(cancoder.getPosition()); // prints the position of the CANCoder
  System.out.println(cancoder.getVelocity()); // prints the velocity recorded by the CANCoder

  ErrorCode error = cancoder.getLastError(); // gets the last error generated by the CANCoder
  CANCoderFaults faults = new CANCoderFaults();
  ErrorCode faultsError = cancoder.getFaults(faults); // fills faults with the current CANCoder faults; returns the last error generated
 */

    flMove.setInverted(true);
    blMove.setInverted(true);
    flTurn.setInverted(true);
    blTurn.setInverted(true);
  }


  @Override
  public void periodic() {
    // This method will be called once per scheduler run
  }
  public void drive(double forward, double rotate, double strafe){ 
    flMove.set(rotate);
    frMove.set(rotate);
    blMove.set(rotate);
    brMove.set(rotate);        
  }
  public void driveForwBack(double forward){
    if(cancoder.getAbsolutePosition() != 0 || cancoder.getAbsolutePosition() != Math.PI){
      flTurn.set(0.7);
      frTurn.set(0.7);
      blTurn.set(0.7);
      brTurn.set(0.7);
    }else{
      flMove.set(forward);
      frMove.set(forward);
      blMove.set(forward);
      brMove.set(forward);
    }
    
  } 
  public void driveRotate(double rotate){
    if(cancoder.getAbsolutePosition() != Math.PI / 4 || cancoder.getAbsolutePosition() != Math.PI * 5 / 4){
      flTurn.set(0.7);
      frTurn.set(0.7);
      blTurn.set(0.7);
      brTurn.set(0.7);
    }else{
      flMove.set(rotate);
      frMove.set(rotate);
      blMove.set(rotate);
      brMove.set(rotate);
    }
    
  }

  
  public CANCoder getFl(){return fl;}
  public CANCoder getFr(){return fr;}
  public CANCoder getBl(){return bl;}
  public CANCoder getBr(){return br;}


  private double closestAngle(double a, double b){
        // get direction
        double dir = modulo(b, 360.0) - modulo(a, 360.0);

        // convert from -360 to 360 to -180 to 180
        if (Math.abs(dir) > 180.0)
        {
                dir = -(Math.signum(dir) * 360.0) + dir;
        }
        return dir;
  }
  private double modulo(double val, double divideBy){
    return val % divideBy;
  }

}
